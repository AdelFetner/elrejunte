\newpage
\section{Estructuras de datos}

\subsection{Ordered set}
Esto solo compila desde C++11.
\lstinputlisting[language=C++]{secciones/estructuras/SetConBS.cpp}

\subsection{Union Find}

\subsubsection{Classic DSU}
\lstinputlisting[language=C++]{secciones/estructuras/UnionFind.cpp}

\subsubsection{DSU with rollbacks}
\lstinputlisting[language=C++]{secciones/estructuras/union_find_rollbacks.cpp}

\subsection{Hash Table}
\lstinputlisting[language=C++]{secciones/estructuras/Hash_table.cpp}

\subsection{Gain cost set}
\lstinputlisting[language=C++]{secciones/estructuras/gain_cost_set.cpp}

\subsection{Disjoint intervals}
\lstinputlisting[language=C++]{secciones/estructuras/disjoint_intervals.cpp}

\subsection{Fenwick Tree}
\lstinputlisting[language=C++]{secciones/estructuras/fenwick_tree.cpp}

\subsection{Segment Tree}
\subsubsection{ST static}
Dado un arreglo y una operacion asociativa \emph{idempotente}, get(i, j) opera sobre el rango [i, j). Restriccion: LVL $\ge$ ceil(logn); Usar [ ] para llenar arreglo y luego build().
\lstinputlisting[language=C++]{secciones/estructuras/rmq_static.cpp}
\subsubsection{ST dynamic}
\lstinputlisting[language=C++]{secciones/estructuras/rmq_dynamic.cpp}
\subsubsection{ST lazy}
\lstinputlisting[language=C++]{secciones/estructuras/rmq_lazy.cpp}
\subsubsection{ST persistente}
\lstinputlisting[language=C++]{secciones/estructuras/rmq_persistent.cpp}
\subsubsection{ST implicit}
\lstinputlisting[language=C++]{secciones/estructuras/rmq_implicit.cpp}
\subsubsection{ST 2d}
\lstinputlisting[language=C++]{secciones/estructuras/rmq_2d.cpp}

\subsection{Li-Chao Tree}
\lstinputlisting[language=C++]{secciones/estructuras/li_chao_tree.cpp}

\subsection{Treap}
\lstinputlisting[language=C++]{secciones/estructuras/treap.cpp}
\subsection{Implicit treap}
\lstinputlisting[language=C++]{secciones/estructuras/treap_implicit.cpp}
\subsection{STL rope}
\lstinputlisting[language=C++]{secciones/estructuras/rope.cpp}


\subsection{BIGInt}
\lstinputlisting[language=C++]{secciones/estructuras/bigint.cpp}
