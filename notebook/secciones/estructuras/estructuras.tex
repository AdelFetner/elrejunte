\newpage
\section{Estructuras de datos}

\subsection{Set Mejorado}
Esto solo compila desde C++11.
\lstinputlisting[language=C++]{secciones/estructuras/SetConBS.cpp}

% \subsection{Disjoint Sets}
\subsection{Union Find}
% \begin{footnotesize}
% 	\textbf{Utiliza:} \texttt{<vector>}\\
% 	\textbf{Notas:} Rangos \texttt{[i,j]} (\textit{0 based}). No recomendable si se tienen que crear y destruir muchos objetos. Probar funcionamiento en casos l\'imites. 
% \end{footnotesize}
% \lstinputlisting[language=C++]{secciones/estructuras/union_find_oop.cpp}
% \subsubsection{Union Find (C Style/Static)}
% \begin{footnotesize}
% 	\textbf{Utiliza:} \texttt{<cstring>}\\
% 	\textbf{Notas:} Rangos \texttt{[i,j]} (\textit{0 based}). En \texttt{init(n)}, \texttt{n $\leq$ MAXN}
% \end{footnotesize}
% \lstinputlisting[language=C++]{secciones/estructuras/union_find_static.cpp}
\lstinputlisting[language=C++]{secciones/estructuras/UnionFind.cpp}

\newpage
\subsection{Hash Table}
\lstinputlisting[language=C++]{secciones/estructuras/Hash_table.cpp}

\subsection{Gain cost set}
\lstinputlisting[language=C++]{secciones/estructuras/gain_cost_set.cpp}

\subsection{Disjoint intervals}
\lstinputlisting[language=C++]{secciones/estructuras/disjoint_intervals.cpp}

\subsection{Segment Tree}
\subsubsection{ST static}
Dado un arreglo y una operacion asociativa \emph{idempotente}, get(i, j) opera sobre el rango [i, j). Restriccion: LVL $\ge$ ceil(logn); Usar [ ] para llenar arreglo y luego build().
\lstinputlisting[language=C++]{secciones/estructuras/rmq_static.cpp}
\subsubsection{ST dynamic}
\lstinputlisting[language=C++]{secciones/estructuras/rmq_dynamic.cpp}
\subsubsection{ST lazy}
\lstinputlisting[language=C++]{secciones/estructuras/rmq_lazy.cpp}
\subsubsection{ST persistente}
\lstinputlisting[language=C++]{secciones/estructuras/rmq_persistent.cpp}
\subsubsection{ST 2d}
\lstinputlisting[language=C++]{secciones/estructuras/rmq_2d.cpp}


\subsection{BIGInt}
\lstinputlisting[language=C++]{secciones/estructuras/bigint.cpp}
