\documentclass[10pt,a4paper,oneside]{article}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{listings}       % for code snipplets.
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

% Listing code style
\lstdefinestyle{codestyle}{
	basicstyle=\footnotesize\ttfamily,
    commentstyle=\rmfamily\itshape,
    keywordstyle=\bfseries,        
    emph={tipo}, % Here we can define customs keywords
    emphstyle=\bfseries,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=bt,
    keepspaces=false,
    numbers=left,
    numberstyle=\scriptsize\ttfamily,
    numbersep=5pt,
    frame=single,
    framesep=3pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}
\lstset{style=codestyle}

% We use Courier font to make bold keywords possible.
\renewcommand{\ttdefault}{pcr}
% We change listings prefix.
\renewcommand{\lstlistingname}{C\'odigo}

%% CHANGE THIS
%The problem's author.
\newcommand{\authorproblem}{Pablo Ariel Heiber, Argentina}
%The solution's author.
\newcommand{\authorsolution}{Nicol\'as Javier Guimar, Argentina}
%The problem's type or category
\newcommand{\problemtype}{Adhoc}
%The problem's title. ID - NAME
\title{7203 - At most twice}
%%

\author{ 
	\small\emph{Autor}: \authorproblem\\ 
	\small\emph{Soluci\'on}: \authorsolution\\
	\small\emph{Catergor\'ia}: \problemtype
}
\date{\today}


\begin{document}
\maketitle

\section*{Soluci\'on}

El problema nos pide, dado un n\'umero entero \textit{U}($1\leq U \leq 10^{18}$), encontrar un n\'umero \textit{L} tal que $L \leq U$, donde \textit{L} no puede repetir m\'as de dos veces cualquiera de sus d\'igitos.

Para esto utilizamos tres vectores:
\begin{itemize}
    \item \texttt{entrada}: donde almacenaremos el n\'umero ingresado. 
    \item \texttt{resultado}: donde iremos generando el n\'umero \textit{L} que tenemos que imprimir por pantalla.
    \item \texttt{frecuencia}: donde almacenaremos la cantidad de ocurrencias de cada d\'igito presente en nuestro vector \texttt{resultado}.
\end{itemize}

La estrategia consiste en recorrer el vector \texttt{entrada}, de izquierda a derecha, e ir copi\'andolo, d\'igito a d\'igito, a nuestro vector \texttt{resultado}$^{[30-38]}$ hasta que:
\begin{itemize}
    
    \item nos encontremos con un d\'igito que ya est\'a dos veces en dicho vector (frecuencia=2). En este caso nos quedamos con el \'indice \texttt{i} de esta ``posici\'on de conflicto'' y procedemos de la siguiente forma. Primero buscamos si existe alg\'un n\'umero \texttt{num} menor que el d\'igito en la ``posici\'on de conflicto'' que tenga una \texttt{frecuencia[num] != 2} $^{[42]}$. Luego: 
    \begin{itemize}
        \item Si encontramos dicho n\'umero, actualizamos su frecuencia, lo insertamos en la posici\'on \texttt{i} de \texttt{resultado}, y llamamos a funci\'on \texttt{rellenar()} con la posici\'on \texttt{i+1} y la logitud del n\'umero ingresado \texttt{len} $^{[58-60]}$. Esta funci\'on$^{[9-19]}$ lo que har\'a es rellenar el vector \texttt{resultado} en el rango \texttt{[inicio,fin)} con los d\'igitos disponibles (seg\'un el vector \texttt{frecuencia}) de mayor a menor. Por \'ultimo se imprime \texttt{resultado} $^{[64]}$.
        \item Si no lo encontramos$^{[44]}$, procedemos a iterar sobre el vector \texttt{entrada} de derecha a izquierda, desde la posici\'on actual \texttt{i} hasta su inicio (\texttt{i=0}) $^{[46]}$. En cada posici\'on decrementaremos la frecuencia del d\'igito que tenemos en \texttt{resultado}, puesto que ya la hemos contabilizado$^{[30-38]}$, y buscaremos nuevamente si existe alg\'un n\'umero \texttt{num} menor que el d\'igito de la posici\'on actual, que tenga una frecuencia $< 2$. Si no existe, seguimos con la posici\'on siguiente$^{[50]}$. Si existe, actualizamos su frecuencia, lo insertamos en \texttt{resultado} y terminamos de rellenar el vector$^{[51-54]}$.\\
        Un caso particular sucede cuando nos encontramos en la primer posici\'on del vector (\texttt{i=0}, \'ultima iteraci\'on) y encontramos que \texttt{num=0}, si rellenamos de posici\'on siguiente a la actual como lo ven\'iamos haciendo, el resultado serÃ­a un n\'umero con la forma \texttt{0xxx...}, lo cual es incorrecto, es por eso que agregamos este caso particular$^{[49]}$ para poder llamar a \texttt{rellenar} en el rango \texttt{[0,len-1)} puesto que el resultado disminuy\'o un orden de magnitud. Finalmente imprimimos \texttt{resultado}.
    \end{itemize}
    \item \'o terminemos de procesar \textit{U}, en cuyo caso s\'olo nos resta imprimir el mismo n\'umero$^{[64]}$ (recordar que puede darse que $L = U$).
\end{itemize}

%
\pagebreak
\section*{C\'odigo}
\lstinputlisting[language=C++, caption=at\_most\_twice.cpp]{at_most_twice.cpp}


\end{document}