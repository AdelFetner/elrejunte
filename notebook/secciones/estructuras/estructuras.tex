\section{Estructuras de datos}

\subsection{Disjoint Sets}
\subsubsection{Union Find (OOP)}
\begin{footnotesize}
	\textbf{Utiliza:} \texttt{<vector>}\\
	\textbf{Notas:} Rangos \texttt{[i,j]} (\textit{0 based}). No recomendable si se tienen que crear y destruir muchos objetos. Probar funcionamiento en casos l\'imites. 
\end{footnotesize}
\lstinputlisting[language=C++]{secciones/estructuras/union_find_oop.cpp}
\subsubsection{Union Find (C Style/Static)}
\begin{footnotesize}
	\textbf{Utiliza:} \texttt{<cstring>}\\
	\textbf{Notas:} Rangos \texttt{[i,j]} (\textit{0 based}). En \texttt{init(n)}, \texttt{n $\leq$ MAXN}
\end{footnotesize}
\lstinputlisting[language=C++]{secciones/estructuras/union_find_static.cpp}

\subsection{Segment Trees}
\subsubsection{Range Sum Query (lazy)}
\begin{footnotesize}
	\textbf{Utiliza:} \texttt{<cmath>}\\
	\textbf{Notas:} Limpiar \texttt{st} y \texttt{lazy} en cada testcase. En \texttt{main()}: \\
	\begin{itemize}
		\item \texttt{N} es la cantidad de elementos del problema.
		\item ($ 0 \leq i,j < N $) \texttt{build(1,0,N-1)}, \texttt{update(1,0,N-1,i,j,value)}, \texttt{query(1,0,N-1,i,j)}. Los elementos en \texttt{arr} tienen que estar desde \texttt{arr[0]}.
		\item ($ 1 \leq i,j \leq N $) \texttt{build(1,1,N)}, \texttt{update(1,1,N,i,j,value)}, \texttt{query(1,1,N,i,j)}. Los elementos en \texttt{arr} tienen que estar desde \texttt{arr[1]}.
	\end{itemize}
\end{footnotesize}
\lstinputlisting[language=C++]{secciones/estructuras/st_range_sum_query_lazy.cpp}

\subsubsection{Range Min/Max Query (lazy)}
\begin{footnotesize}
	\textbf{Utiliza:} \texttt{<cmath>}\\
	\textbf{Notas:} Limpiar \texttt{st} y \texttt{lazy} en cada testcase. En \texttt{main()}: \\
	\begin{itemize}
		\item \texttt{N} es la cantidad de elementos del problema.
		\item ($ 0 \leq i,j < N $) \texttt{build(1,0,N-1)}, \texttt{update(1,0,N-1,i,j,value)}, \texttt{query(1,0,N-1,i,j)}. Los elementos en \texttt{arr} tienen que estar desde \texttt{arr[0]}.
		\item ($ 1 \leq i,j \leq N $) \texttt{build(1,1,N)}, \texttt{update(1,1,N,i,j,value)}, \texttt{query(1,1,N,i,j)}. Los elementos en \texttt{arr} tienen que estar desde \texttt{arr[1]}.
	\end{itemize}
\end{footnotesize}
\lstinputlisting[language=C++]{secciones/estructuras/st_range_min_max_query_lazy.cpp}