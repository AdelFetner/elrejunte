# TECNOMATE 2017
[sitio oficial](https://tecnomate.xyz/2017/)

* [Categoria Secundaria](#categoria-secundaria)
* [Categoria Algoritmos](#categoria-algoritmos)
* [Categoria Paradigmas](#categoria-paradigmas)
* [Categoria Libres](#categoria-libres)

# Categoria SECUNDARIA

## Problema 1: [General Exam](https://www.urionlinejudge.com.br/judge/en/problems/view/2534)

Si se sabe utilizar vectores o arrays, se cargan al mismo las notas. Luego de estar cargadas se ordenan.

Y luego las queries son las posiciones (indexando desde 1) en ese vector/array ordenado.

Se puede hacer con un array y un ordenamiento propio, al ser pocas notas, va a entrar en tiempo.
*Complejidad:* O(n).

## Problema 2: [Krapeskar](https://www.urionlinejudge.com.br/judge/en/problems/view/1785)

Greedy con implementación medianamente complicada.

Lo dificil de este problema es implementar las funciones para sacar el mayor número y menor número con esos digitos.

Al darse cuenta que si se ordenan los dígitos dan los dos números (menor a mayor da el menor número posible, y de mayor a menor da el mayor número posible) se soluciona fácilmente.
Y es aún más fácil de implementar si el número se toma como **string**.

Hay que tambien tener en cuenta que si en la iteración da un número en el que se repita un dígito, es el resultado `-1`.

## Problema 3: [Blue Lagoon](https://www.urionlinejudge.com.br/judge/en/problems/view/2178)

El problema tiene un caso `tricky` para un pajaro que es el siguiente:
```
1 5
1 3 0
```
En ese caso tomaría **1** vuelta atrapar a ese pájaro.
Luego lo que debo hacer es contar para cada pájaro las vueltas necesarias para atraparlo. Recorriendo los puntos a donde vuela, si el punto en el que estoy es menor al anterior, di una vuelta. *Teniendo en cuenta el caso del 0*.

La mayor cantidad de vueltas es la respuesta.

## Problema 4: [Travel To Mars in primo speed](https://www.urionlinejudge.com.br/judge/en/problems/view/2180)

Con ir de a un número comprobando si es primo, y sumando los 10 primeros ya soluciona el problema.

Con el algoritmo de comprobación de primo común entra en tiempo.
```
bool is_prime(int n){
	if(n < 2) return false;
	for(int x = 2; x*x <= n; x++){
		if(n%x == 0)return false;
	}
	return true;
}
```
Calcular las horas y los días es una simple división al tener la velocidad calculada.

## Problema 5: [Virus](https://www.urionlinejudge.com.br/judge/en/problems/view/2567)

Problema ***Greedy***. La suma ideal/optima se logra armando los pares con el número más grande y el más chico.

Entonces ordenando un vector con los virus, y tomando los "extremos" para armar los pares, conseguimos el resultado.

En caso de ser un **N impar**, el virus del "medio" es el que se ignora.

## Problema 6: [Maquina de Cafe](https://www.urionlinejudge.com.br/judge/en/problems/view/2670)

Al ser solo 3 pisos se pueden probar las 3 posibles situaciones, y mostrar la más optima (la que de menos tiempo `T`).
```
1. Si la maquina esta en Planta baja. T = a1*2 + a2*4
2. Si la maquina esta en el 1er Piso. T = a0*2 + a2*2
3. Si la maquina esta en el 2do Piso. T = a0*4 + a1*2
```

## Problema 7: [Building Walls](https://www.urionlinejudge.com.br/judge/en/problems/view/2650)

Este problema tiene una implementación tediosa al tener que en una misma línea tomar dos valores `nombre del titan` y `altura`.

Hay un par de funciones que se deben saber para poder tomar una sola línea:
```c++
string temp;
getline(cin,temp);
```
Con `getline` podemos tomar una linea entera, y guardarlo en un `string`.
O sino se puede ir tomando caracteres hasta que haya un salto de linea:
```c++
char linea[]="";
char c = getchar();
while(c!='\n'){
	linea += c;
}
```

Luego es cuestión de parsear esa línea, lo más directo es ir recorriendola de atrás para adelante, de a un carácter hasta encontrar un espacio.

De esta manera, tenemos de un lado el string que represente el nombre del titan, y del otro su altura.

Hay muchas formas de pasar un string a número, vamos a mostrar 2:

La más directa, pero que hay que utilizar una librería:
```c++
#include <sstream>
string altura;
int height;
istringstream (altura) >> height;
```
Y la otra menos directa, pero sin utilizar librerías:
```c++
string altura;
int height = 0;
for(int i=0; i < altura.length(); i++){
	height += (altura[i]-'0') * pow(10,(altura.length()-1 - i));
}
```

Luego de tener estos datos es solo cuestión de comparar si la altura es mayor a la de la pared, e imprimir el nombre del titán si así lo es.

## Problema 8: [Image](https://www.urionlinejudge.com.br/judge/en/problems/view/1516)

La solución es sencilla, solamente debemos implementar lo que nos dice el enunciado; esto puede generar alguna complicación pero no hay nada extra que pensar.
Básicamente, para cada caso podemos leer la "imágen" en una matriz de caracteres e imprimir cada fila a/n veces y, al imprimir una fila, imprimir b/m veces cada caracter.

```c++
//C++
for(int i=0;i<n;i++)
	for(int f=0;f<a/n;f++) //cada fila a/n veces
	{
		for(int j=0;j<m;j++)
			for(int c=0;c<b/m;c++) //cada columna b/m veces
				cout << imagen[i][j];
		cout << "\n";
	}
```

## Problema 9: [Super Primes: Engage!](https://www.urionlinejudge.com.br/judge/en/problems/view/2674)

Si se toma el **N** como un `string`. Es bastante directo.
Debemos analizar hacer 2 cosas:
1. *N es primo?*. Esto se sabe fácil pasando N a `int`. Y analizando con cualquier algoritmo de primos si lo es.
2. *Todos los digitos de N son primos?* Esto se sabe recorriendo digito por digito (caracter a caracter), y vamos viendo si el mismo es primo. Esto es directo si sabemos los primos de un dígito `{2,3,5,7}`.

Luego es solo armar una estructura condicional donde si cumple las dos condiciones es `Super`, si es solo la primera `Primo`, y sino `Nada`.

## Problema 10: [What is the Fastest?](https://www.urionlinejudge.com.br/judge/en/problems/view/2175)

Lo importante de este problema es tomar los datos como `float` o `double`.

Comparandolos de esta manera, con una usar una estructura `if{}else if{} else` solucionamos este problema.


# Categoria Algoritmos

## Problema 1: Máquina de Café
[Problema 6 de Secundaria](#problema-6-maquina-de-cafe)

## Problema 2: Palindrome Double

## Problema 3: Help Girafales!

Problema complicado de solucionar si no se conoce la estructura `map<string, string>`.

Proponemos una solucion que utiliza `vector`.

Creamos dos vectores de strings, uno para guardar los nombres y otro para las firmas.

Luego vamos cargando los nombres y firmas a comprobar. Linea por linea lo que hacemos es:
1. Buscar el nombre en el vector, para conocer su indice `i`.
2. Comparamos la firma correcta `firmas[i]`, con la ingresada.
3. Para comparar lo hacemos caracter a caracter, y vamos contando las diferencias. Esto se puede hacer con un simple `for`.
4. Si las diferencias son mayor que `1`, le sumamos 1 a nuestra respuesta.

## Problema 4: Image
[Problema 8 de Secundaria.](#problema-8-image)

## Problema 5: Train Swapping

En resumen el problema nos pregunta ¿Cuál es la mínima cantidad de operaciones a realizar para ordenar un conjunto de números, si la única operación permitida es intercambian dos números que estén en posiciones adyacentes (swap)?. El [ordenamiento burbuja](https://es.wikipedia.org/wiki/Ordenamiento_de_burbuja) es un algoritmo bien conocido que justamente hace eso. Como la entrada es pequeña podemos simplemente correr este ordenamiento y contar la cantidad de swaps que se realizan, que será nuestra respuesta; la complejidad para cada caso será O(L^2). También existe una solución más eficiente con complejidad O(LlogL).

## Problema 6: Hunting Digletts

Es clave entender que el enunciado nos dice que las cuevas forman un conjunto de `circuitos` o `ciclos`. Luego, digamos que dichas cuevas forman **K** circuitos: **C_1,C_2,...,C_k** y sus longitudes son respectivamente: **L_1,L_2,...L_k**; entonces cada Diglett viajará por alguno de estos circuitos y especificamente el Diglett que viaja por **C_i** se asomará cada **L_i** segundos a la superficie. Finalmente es bastante intuitivo pensar que todos los Digletts se asomarán al mismo tiempo cuando el tiempo transcurrido sea **múltiplo** de todos las longitudes de los circuitos. Es decir que para encontrar el mínimo debemos calcular el **mínimo común múltiplo** (`mcm`) de estas longitudes, `mcm(L_1,L_2,...,L_k)`.

Entonces, primero debemos obtener las longitudes de los circuitos, que es bastante sencillo. Luego debemos calcular el `mcm`, y la forma mas sencilla de hacer esto es teniendo en cuenta lo siguiente:
1. `mcm(a,b,c) = mcm(mcm(a,b),c) = mcm(a,mcm(b,c))` (es decir que la "operación" `mcm` es **asociativa** y **conmutativa**)
2. `mcm(a,b) = (a*b)/mcd(a,b)`. Siendo `mcd` el **máximo común divisor**, que puede calcularse de manera sencilla usando el [Algoritmo de Euclides](https://es.wikipedia.org/wiki/Algoritmo_de_Euclides). A continuación dejamos una sencilla implementación del mismo:

```c++
//C++
int mcd(int a,int b)
{
	if(b==0) return a;
	return mcd(b,a%b);
}
```

## Problema 7: Sort!, sort! and sort!!!

Está más que claro que lo que debemos hacer es ordenar un conjunto de números según varios criterios.
Para ordenar un conjunto de números, sea cual sea el algoritmo que apliquemos (selección, inserción, burbuja, merge, etc.), en alguna parte del código seguro comparamos pares de números para conocer su orden relativo. Si por ejemplo queremos ordenar de menor a mayor en algún lugar tendremos algo parecido a:

```c++
//C++
if(x<y)
{
	//x estará antes que y en el orden final
	...
}
else
{
	//y estará antes que x en el orden final
	...
}
```

Luego, para resolver el problema podemos pensarlo igual que un ordenamiento "común" pero donde la condición de precedencia será un poco más compleja. Una forma sencilla de hacer esto es armar una función que reciba dos números como parámetro y retorne un valor de verdad indicando si el primer parámetro precede al segundo o no. Si dicha función por ejemplo la llamamos `comparar`, el código de arriba cambiaría a:

```c++
//C++
if(comparar(x,y))
{
	//x estará antes que y en el orden final
	...
}
else
{
	//y estará antes que x en el orden final
	...
}
```

Luego solo resta implementar correctamente dicha función y aplicar algún método de ordenamiento que conozcamos. Nosotros definimos a `comparar` de la sigueinte manera:

```c++
//C++
bool comparar(int a, int b) //retorna verdadero si a precede a b
{
	if(a%m!=b%m) return a%m<b%m; 
	if(a%2!=b%2 && a%2!=-(b%2)) return (a%2)!=0;
	if(a%2==0) return a<b;
	return a>b;
}
```

## Problema 8: The Greater One Digit Number

Uno de los problemas díficiles si no se sabe trabajar con `strings`.

Nuestra solución básicamente lo que hace es lo siguiente:
1. Tomar la entrada como dos `strings`.
2. Para cada uno de estos strings se calcula el *OneDigitNumber*.
3. Se comparan los *OneDigitNumber* y se da la salida adecuada.

Para calcular el *OneDigitNumber* armamos una función recursiva:
```c++
int single_digit(string x){
	if(x.length()==1) return x[0]-'0';
	else{
		int n=0;
		for(int i=0;i < x.length(); i++){
			n += (x[i]-'0');
		}
		return single_digit(num_to_str(n));//la función para pasar int a string se ve más arriba.
	}
}
```

Hay un caso tricky (tramposo) que rompe alguna posible solución que es el siguiente:
```
1 0 \\ salida "1"
0 1 \\ salida "2"
0 0
```

## Problema 9: Super Primes Engage
[Problema 9 de Secundaria.](#problema-9-super-primes-engage)

## Problema 10: Building Walls
[Problema 7 de Secundaria.](#problema-7-building-walls)

# Categoria Paradigmas

## Problema 1: Easy Problem

## Problema 2: Amusing numbers

## Problema 3: How to Handle the Fans

## Problema 4: Queue (Pro)

## Problema 5: Atoms in the Lab

## Problema 6: RK Sorting

Este problema sale teniendo en cuenta dos cosas:
1. La estructura en la que guardamos nuestros "datos".
2. Armando una función de comparación para el sort.

La estructura en particular que arme yo es media rebuscada (puede salir con otra).

Lo que hago primero es cargar un `map<int, pair<int,int>>` donde la key es el número que se lee, y en el par cargo la cantidad de apariciones y el primer indíce.

Luego con ese `map`, cargo un vector de ternas `pair<pair<int,int>,int>`(número), y luego ordeno el vector con la función de `sort` que defini según lo que pide el problema.

## Problema 7: Encode Integer

# Categoria Libres

## Problema 1: Grouping Dishes

Lo complicado del problema es *parsear* la entrada. Hay varias formas de hacer esto.
Cuando ya tenemos parseada la entrada, es cuestion de guardar cada ingrediente en un `map<string, vector<string>>`. Donde la `key` es el ingrediente, y se le va asociando las diferentes comidas.
Por último es cuestión de recorrer el map, y solo mostrar aquellos ingredientes que tengan más de **1** comida asociada.
Para que las comidas esten lexicograficamente ordenadas, es solo cuestión de mostrarlas ordenada por un `sort`.

## Problema 2: Reverse Pairs

## Problema 3: Friend Circles

Este problema es encontrar las **componentes conexas** en el grafo dado en el input.

Al ser bi-direccional, se pueden contar corriendo simples **DFS**.

## Problema 4: Binary Watch

Este problema sale con **brute force**(fuerza bruta).

Haciendo un doble for anidado:
```c++
for(h=0;h<12;h++){
	for(m=0;m<60;m++){
		if(cant_bits(h)+cant_bits(m) == N) count++;
	}
}
```
Luego mostramos nuestra variable `count`(contador), y listo.

Formas de contar bits, hay varias, pero compartimos la que usamos:
```c++
int cant_bits(int x){
	int cant=0;
	for(int i=0;i<6;i++){ //controla los 6 bits menos significativos
		if(x&(1<<i)) cant++;
	}
	return cant;
}
```

## Problema 5: Kill Process

Este problema es cuestión de armar el **árbol** con el input dado.

Y luego teniendo el *PID* (nodo a eliminar), es cuestión de hacer un **DFS** desde ese nodo, e ir guardando los PID que vamos recorriendo.

Por último, mostramos esos PID ordenados.

## Problema 6: Climbing Stairs

Si se analiza el problema se puede ver la siguiente recursividad:
```
f(n) = f(n-1) + f(n-2)
con
f(0) = 1
f(1) = 1
```
Es Fibonacci!!
Pero, en el caso de que la entrada sea `0`, la respuesta es `0`. Este es el caso `tricky` que puede romper el análisis.

Como `N<=50`, una implementación recursiva directa de Fibonacci va a dar `TLE`, por `O(2^N)`.

Implementado una DP o memorización, se consigue de manera lineal `O(n)`.

## Problema 7: The Cube

## Problema 8: FNDI's Network

Construir el **árbol de cobertura mínimo** sobre el grafo completo (unir todo par de puntos del input).

Se puede usar `Prim` o `Kruskal`, nosotros no tuvimos problemas, pero sabemos de equipos que tuvieron problemas por precisión.

## Problema 9: El Dorado



