\section{Estructuras de datos}

\subsection{Set Mejorado}
Esto solo compila en C++11.
\lstinputlisting[language=C++]{secciones/estructuras/SetConBS.cpp}

% \subsection{Disjoint Sets}
\subsection{Union Find}
% \begin{footnotesize}
% 	\textbf{Utiliza:} \texttt{<vector>}\\
% 	\textbf{Notas:} Rangos \texttt{[i,j]} (\textit{0 based}). No recomendable si se tienen que crear y destruir muchos objetos. Probar funcionamiento en casos l\'imites. 
% \end{footnotesize}
% \lstinputlisting[language=C++]{secciones/estructuras/union_find_oop.cpp}
% \subsubsection{Union Find (C Style/Static)}
% \begin{footnotesize}
% 	\textbf{Utiliza:} \texttt{<cstring>}\\
% 	\textbf{Notas:} Rangos \texttt{[i,j]} (\textit{0 based}). En \texttt{init(n)}, \texttt{n $\leq$ MAXN}
% \end{footnotesize}
% \lstinputlisting[language=C++]{secciones/estructuras/union_find_static.cpp}
\lstinputlisting[language=C++]{secciones/estructuras/UnionFind.cpp}

\subsection{Hash Table}
\lstinputlisting[language=C++]{secciones/estructuras/Hash_table.cpp}

\subsection{RMQ}
\subsubsection{RMQ (static)}
Dado un arreglo y una operacion asociativa \emph{idempotente}, get(i, j) opera sobre el rango [i, j). Restriccion: LVL $\ge$ ceil(logn); Usar [ ] para llenar arreglo y luego build().
\lstinputlisting[language=C++]{secciones/estructuras/rmq_static.cpp}
\subsubsection{RMQ (dynamic)}
\lstinputlisting[language=C++]{secciones/estructuras/rmq_dynamic.cpp}
\subsubsection{RMQ (lazy)}
\lstinputlisting[language=C++]{secciones/estructuras/rmq_lazy.cpp}
\subsubsection{RMQ (persistente)}
\lstinputlisting[language=C++]{secciones/estructuras/rmq_persistent.cpp}

\subsection{BIGInt}
\lstinputlisting[language=C++]{secciones/estructuras/bigint.cpp}
