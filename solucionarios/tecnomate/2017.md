# Nivel SECUNDARIA

## Problema 1: General Exam

Si se sabe utilizar vectores o arrays, se cargan al mismo las notas. Luego de estar cargadas se ordenan.

Y luego las queries son las posiciones (indexando desde 1) en ese vector/array ordenado.

Se puede hacer con un array y un ordenamiento propio, al ser pocas notas, va a entrar en tiempo.
*Complejidad:* O(n).

## Problema 2: Krapeskar

Greedy con implementación medianamente complicada.

Lo dificil de este problema es implementar las funciones para sacar el mayor número y menor número con esos digitos.

Al darse cuenta que si se ordenan los dígitos dan los dos números (menor a mayor da el menor número posible, y de mayor a menor da el mayor número posible) se soluciona fácilmente.
Y es aún más fácil de implementar si el número se toma como **string**.

Hay que tambien tener en cuenta que si en la iteración da un número en el que se repita un dígito, es el resultado `-1`.

## Problema 3: Blue Lagoon

El problema tiene un caso `tricky` para un pajaro que es el siguiente:
```
1 5
1 3 0
```
En ese caso tomaría **1** vuelta atrapar a ese pájaro.
Luego lo que debo hacer es contar para cada pájaro las vueltas necesarias para atraparlo. Recorriendo los puntos a donde vuela, si el punto en el que estoy es menor al anterior, di una vuelta. *Teniendo en cuenta el caso del 0*.

La mayor cantidad de vueltas es la respuesta.

## Problema 4: Travel To Mars in primo speed

Con ir de a un número comprobando si es primo, y sumando los 10 primeros ya soluciona el problema.

Con el algoritmo de comprobación de primo común entra en tiempo.
```
bool is_prime(int n){
	if(n < 2) return false;
	for(int x = 2; x*x <= n; x++){
		if(n%x == 0)return false;
	}
	return true;
}
```
Calcular las horas y los días es una simple división al tener la velocidad calculada.

## Problema 5: Virus

Problema ***Greedy***. La suma ideal/optima se logra armando los pares con el número más grande y el más chico.

Entonces ordenando un vector con los virus, y tomando los "extremos" para armar los pares, conseguimos el resultado.

En caso de ser un **N impar**, el virus del "medio" es el que se ignora.

## Problema 6: Máquina de Café

Al ser solo 3 pisos se pueden probar las 3 posibles situaciones, y mostrar la más optima (la que de menos tiempo `T`).
```
1. Si la maquina esta en Planta baja. T = a1*2 + a2*4
2. Si la maquina esta en el 1er Piso. T = a0*2 + a2*2
3. Si la maquina esta en el 2do Piso. T = a0*4 + a1*2
```

## Problema 7: Building Walls

Este problema tiene una implementación tediosa al tener que en una misma línea tomar dos valores `nombre del titan` y `altura`.

Hay un par de funciones que se deben saber para poder tomar una sola línea:
```c++
string temp;
getline(cin,temp);
```
Con `getline` podemos tomar una linea entera, y guardarlo en un `string`.
O sino se puede ir tomando caracteres hasta que haya un salto de linea:
```c++
char linea[]="";
char c = getchar();
while(c!='\n'){
	linea += c;
}
```

Luego es cuestión de parsear esa línea, lo más directo es ir recorriendola de atrás para adelante, de a un carácter hasta encontrar un espacio.

De esta manera, tenemos de un lado el string que represente el nombre del titan, y del otro su altura.

Hay muchas formas de pasar un string a número, vamos a mostrar 2:

La más directa, pero que hay que utilizar una librería:
```c++
#include <sstream>
string altura;
int height;
istringstream (altura) >> height;
```
Y la otra menos directa, pero sin utilizar librerías:
```c++
string altura;
int height = 0;
for(int i=0; i < altura.length(); i++){
	height += (altura[i]-'0') * pow(10,(altura.length()-1 - i));
}
```

Luego de tener estos datos es solo cuestión de comparar si la altura es mayor a la de la pared, e imprimir el nombre del titán si así lo es.

## Problema 8: Image

Uno de los díficiles si no se sabe manejar vectores y strings.
La solución que encontre es guardar la *"imagen"* de entrada en un `vector<string>`.

Luego armar un nuevo vector, que va a tener la misma cantidad de filas que el original. Este vector lo voy armando, repitiendo cada caracter `b/m` veces.

Y luego muestro cada fila `a/n` veces.

## Problema 9: Super Primes Engage

Si se toma el **N** como un `string`. Es bastante directo.
Debemos analizar hacer 2 cosas:
1. *N es primo?*. Esto se sabe fácil pasando N a `int`. Y analizando con cualquier algoritmo de primos si lo es.
2. *Todos los digitos de N son primos?* Esto se sabe recorriendo digito por digito (caracter a caracter), y vamos viendo si el mismo es primo. Esto es directo si sabemos los primos de un dígito `{2,3,5,7}`.

Luego es solo armar una estructura condicional donde si cumple las dos condiciones es `Super`, si es solo la primera `Primo`, y sino `Nada`.

## Problema 10: What is the Fastest?

Lo importante de este problema es tomar los datos como `float` o `double`.

Comparandolos de esta manera, con una usar una estructura `if{}else if{} else` solucionamos este problema.


# Nivel AEDD

## Problema 1: Máquina de Café
[Problema 6 de Secundaria](#problema-6-máquina-de-cafe)

## Problema 2: Palindrome Double

## Problema 3: Help Girafales!

Problema complicado de solucionar si no se conoce la estructura `map<string, string>`.

Proponemos una solucion que utiliza `vector`.

Creamos dos vectores de strings, uno para guardar los nombres y otro para las firmas.

Luego vamos cargando los nombres y firmas a comprobar. Linea por linea lo que hacemos es:
1. Buscar el nombre en el vector, para conocer su indice `i`.
2. Comparamos la firma correcta `firmas[i]`, con la ingresada.
3. Para comparar lo hacemos caracter a caracter, y vamos contando las diferencias. Esto se puede hacer con un simple `for`.
4. Si las diferencias son mayor que `1`, le sumamos 1 a nuestra respuesta.

## Problema 4: Image
[Problema 8 de Secundaria.](#problema-8-image)

## Problema 5: Train Swapping

Correr un [ordenamiento burbuja](https://es.wikipedia.org/wiki/Ordenamiento_de_burbuja) y contar la cantidad de swaps que se hacen.

## Problema 6: Hunting Digletts

Identificar las longitudes de cada ciclo (cantidad de cuevas que recorre un diglett hasta volver a su cueva), y calcular el **Mínimo común múltiplo (mcm)** entre estas longitudes.

Dos cosas a tener en cuenta para calcular rápidamente `mcm`:
1.  `mcm(a,b,c) = mcm(mcm(a,b),c) = mcm(a,mcm(b,c))`
2. `mcm(a,b) = (a*b)/mcd(a,b)`. Siendo `mcd` el **Maximo Común Divisor**, siendo este fácil de calcular con el algoritmo de Euclides.


## Problema 7: Sort!, sort! and sort!!!

Para poder resolver este problema de una manera "fácil" o directa, necesitamos utilizar la función `sort()` de la librería `<algorithm>`.

El `sort` se puede utilizar con cualquier `collection` de `c++`. Más información [acá](http://www.cplusplus.com/reference/algorithm/sort/).

Entonces cargamos un vector o array con los números, y lo importante es definir una función de ordenamiento, respetando lo que pide el problema. Así queda la que hicimos nosotros:
```c++
bool comparar(int a, int b){ //retorna verdadero si a precede a b
	if(a%m!=b%m) return a%m<b%m; 
	if(a%2!=b%2 && a%2!=-(b%2)) return (a%2)!=0;
	if(a%2==0) return a<b;
	return a>b;
}

sort(array,array+n,comparar);
```

Sin conocer la función `sort`, se puede solucionar implementando algún algoritmo de ordenamiento de complejidad `O(n log n)`. Por ej, [Merge Sort](https://es.wikipedia.org/wiki/Ordenamiento_por_mezcla).


## Problema 8: The Greater One Digit Number

## Problema 9: Super Primes Engage
[Problema 9 de Secundaria.](#problema-9-super-primes-engage)

## Problema 10: Building Walls
[Problema 7 de Secundaria.](#problema-7-building-walls)

# Nivel Libres

## Problema 1: Grouping Dishes

Lo complicado del problema es *parsear* la entrada. Hay varias formas de hacer esto.
Cuando ya tenemos parseada la entrada, es cuestion de guardar cada ingrediente en un `map<string, vector<string>>`. Donde la `key` es el ingrediente, y se le va asociando las diferentes comidas.
Por último es cuestión de recorrer el map, y solo mostrar aquellos ingredientes que tengan más de **1** comida asociada.
Para que las comidas esten lexicograficamente ordenadas, es solo cuestión de mostrarlas ordenada por un `sort`.

## Problema 2: Reverse Pairs

## Problema 3: Friend Circles

Este problema es encontrar las **componentes conexas** en el grafo dado en el input.

Al ser bi-direccional, se pueden contar corriendo simples **DFS**.

## Problema 4: Binary Watch

Este problema sale con **brute force**(fuerza bruta).

Haciendo un doble for anidado:
```c++
for(h=0;h<12;h++){
	for(m=0;m<60;m++){
		if(cant_bits(h)+cant_bits(m) == N) count++;
	}
}
```
Luego mostramos nuestra variable `count`(contador), y listo.

Formas de contar bits, hay varias, pero compartimos la que usamos:
```c++
int cant_bits(int x){
	int cant=0;
	for(int i=0;i<6;i++){ //controla los 6 bits menos significativos
		if(x&(1<<i)) cant++;
	}
	return cant;
}
```

## Problema 5: Kill Process

Este problema es cuestión de armar el **árbol** con el input dado.

Y luego teniendo el *PID* (nodo a eliminar), es cuestión de hacer un **DFS** desde ese nodo, e ir guardando los PID que vamos recorriendo.

Por último, mostramos esos PID ordenados.

## Problema 6: Climbing Stairs

Si se analiza el problema se puede ver la siguiente recursividad:
```
f(n) = f(n-1) + f(n-2)
con
f(0) = 1
f(1) = 1
```
Es Fibonacci!!
Pero, en el caso de que la entrada sea `0`, la respuesta es `0`. Este es el caso `tricky` que puede romper el análisis.

Como `N<=50`, una implementación recursiva directa de Fibonacci va a dar `TLE`, por `O(2^N)`.

Implementado una DP o memorización, se consigue de manera lineal `O(n)`.

## Problema 7: The Cube

## Problema 8: FNDI's Network

Construir el **árbol de cobertura mínimo** sobre el grafo completo (unir todo par de puntos del input).

Se puede usar `Prim` o `Kruskal`, nosotros no tuvimos problemas, pero sabemos de equipos que tuvieron problemas por precisión.

## Problema 9: El Dorado



