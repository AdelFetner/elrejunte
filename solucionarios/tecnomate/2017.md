## Nivel SECUNDARIA

### Problema 1: General Exam

Si se sabe utilizar vectores o arrays, se cargan al mismo las notas. Luego de estar cargadas se ordenan.

Y luego las queries son las posiciones (indexando desde 1) en ese vector/array ordenado.

Se puede hacer con un array y un ordenamiento propio, al ser pocas notas, va a entrar en tiempo.
*Complejidad:* O(n).

### Problema 2: Krapeskar

Greedy con implementación medianamente complicada.

Lo dificil de este problema es implementar las funciones para sacar el mayor número y menor número con esos digitos.

Al darse cuenta que si se ordenan los dígitos dan los dos números (menor a mayor da el menor número posible, y de mayor a menor da el mayor número posible) se soluciona fácilmente.
Y es aún más fácil de implementar si el número se toma como **string**.

Hay que tambien tener en cuenta que si en la iteración da un número en el que se repita un dígito, es el resultado `-1`.

### Problema 3: Blue Lagoon

El problema tiene un caso `tricky` para un pajaro que es el siguiente:
```
1 5
1 3 0
```
En ese caso tomaría **1** vuelta atrapar a ese pájaro.
Luego lo que debo hacer es contar para cada pájaro las vueltas necesarias para atraparlo. Recorriendo los puntos a donde vuela, si el punto en el que estoy es menor al anterior, di una vuelta. *Teniendo en cuenta el caso del 0*.

La mayor cantidad de vueltas es la respuesta.

### Problema 4: Travel To Mars in primo speed

Con ir de a un número comprobando si es primo, y sumando los 10 primeros ya soluciona el problema.

Con el algoritmo de comprobación de primo común entra en tiempo.
```
bool is_prime(int n){
	if(n < 2) return false;
	for(int x = 2; x*x <= n; x++){
		if(n%x == 0)return false;
	}
	return true;
}
```
Calcular las horas y los días es una simple división al tener la velocidad calculada.

### Problema 5: Virus

Problema ***Greedy***. La suma ideal/optima se logra armando los pares con el número más grande y el más chico.

Entonces ordenando un vector con los virus, ÿ tomando los "extremos" para armar los pares, conseguimos el resultado.

En caso de ser un **N impar**, el virus del "medio" es el que se ignora.

### Problema 6: Máquina de Café

Al ser solo 3 pisos se pueden probar las 3 posibles situaciones, y mostrar la más optima (la que de menos tiempo `T`).
```
1. Si la maquina esta en Planta baja. T = a1*2 + a2*4
2. Si la maquina esta en el 1er Piso. T = a0*2 + a2*2
3. Si la maquina esta en el 2do Piso. T = a0*4 + a1*2
```

### Problema 7: Building Walls

Este problema tiene una implementación tediosa al tener que en una misma línea tomar dos valores `nombre del titan` y `altura`.


### Problema 8: Image

Uno de los díficiles si no se sabe manejar vectores y strings.
La solución que encontre es guardar la *"imagen"* de entrada en un `vector<string>`.

Luego armar un nuevo vector, que va a tener la misma cantidad de filas que el original. Este vector lo voy armando, repitiendo cada caracter `b/m` veces.

Y luego muestro cada fila `a/n` veces.

### Problema 9: Super Primes Engage

Si se toma el **N** como un `string`. Es bastante directo.
Debemos analizar hacer 2 cosas:
1. *N es primo?*. Esto se sabe fácil pasando N a `int`. Y analizando con cualquier algoritmo de primos si lo es.
2. *Todos los digitos de N son primos?* Esto se sabe recorriendo digito por digito (caracter a caracter), y vamos viendo si el mismo es primo. Esto es directo si sabemos los primos de un dígito `{2,3,5,7}`.

Luego es solo armar una estructura condicional donde si cumple las dos condiciones es `Super`, si es solo la primera `Primo`, y sino `Nada`.

### Problema 10: What is the Fastest?

Lo importante de este problema es tomar los datos como `float` o `double`.

Comparandolos de esta manera, con una usar una estructura `if{}else if{} else` solucionamos este problema.


## Nivel AEDD

### Problema 1: Máquina de Café
Problema 6 de Secundaria

### Problema 2: Palindrome Double

### Problema 3: Help Girafales!

### Problema 4: Image
Problema 8 de Secundaria.

### Problema 5: Train Swapping

### Problema 6: Hunting Digletts

### Problema 7: Sort!, sort! and sort!!!

### Problema 8: The Greater One Digit Number

### Problema 9: Super Primes Engage
Problema 9 de Secundaria.

### Problema 10: Building Walls
Problema 7 de Secundaria.

## Nivel Libres

### Problema 1: Grouping Dishes

Lo complicado del problema es *parsear* la entrada. Hay varias formas de hacer esto.
Cuando ya tenemos parseada la entrada, es cuestion de guardar cada ingrediente en un `map<string, vector<string>>`. Donde la `key` es el ingrediente, y se le va asociando las diferentes comidas.
Por último es cuestión de recorrer el map, y solo mostrar aquellos ingredientes que tengan más de **1** comida asociada.
Para que las comidas esten lexicograficamente ordenadas, es solo cuestión de mostrarlas ordenada por un `sort`.

### Problema 2: Reverse Pairs

### Problema 3: Friend Circles

Este problema es encontrar las **componentes conexas** en el grafo dado en el input.

Al ser bi-direccional, se pueden contar corriendo simples **DFS**.

### Problema 4: Binary Watch

### Problema 5: Climbing Stairs

### Problema 6: Cube

### Problema 7: FNDI's Network

### Problema 8: El Dorado



